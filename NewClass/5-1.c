#define _CRT_SECURE_NO_WARNINGS 1

#include <stdio.h>

//操作符

//算数操作符 + - * / %

//int main()
//{
//	//int a = 6 / 5;//0.6
//	//printf("%d\n", a);
//
//	//float a = 6 / 5;
//	//printf("%f\n", a);
//
//	float a = 6.0 / 5.0;
//	printf("%f\n", a);
//
//	return 0;
//}
//int main()
//{
//	int a = 7 % 3;//
//	printf("%d\n", a);
//
//	return 0;
//}
//int main()
//{
//	int a = 2;
//	//把a的二进制位向左移动一位
//	int b = a << 1;
//
//	printf("b = %d\n", b);
//
//	return 0;
//}

//移位操作符 >> <<

//int main()
//{
//	int a = 10;
//
//	//把a的二进制位向右移动1位
//	int b = a >> 1;
//
//	printf("a = %d\n", a);
//	printf("b = %d\n", b);
//
//	return 0;
//}
//int main()
//{
//	int a = -1;
//	//把a的二进制位向右移动1位
//	int b = a >> 1;
//	//当前的右移操作符使用的：算术右移
//	printf("b = %d\n", b);
//
//	return 0;
//}
//int main()
//{
//	int a = 10;
//	int b = a << -5;//
//
//	return 0;
//}
//

//位操作符 & | ^

//int main()
//{
//	int a = 3;
//	int b = 5;
//
//	//^  - 按（2进制）位异或
//	//对应的二进制位进行异或
//	//规则：相同为0，相异为1
//
//	int c = a ^ b;
//	printf("%d\n", c);
//
//	//00000000000000000000000000000011
//	//00000000000000000000000000000101
//	//00000000000000000000000000000110
//	//6
//
//
//	//  | - 按（2进制）位或
//	//int c = a | b;
//	//printf("%d\n", c);
//
//	//00000000000000000000000000000011
//	//00000000000000000000000000000101
//	//00000000000000000000000000000111
//	
//	 
//	// 
//	//& -  按（2进制）位与
//	//int c = a & b;
//	//printf("c = %d\n", c);
//	//
//	//00000000000000000000000000000011
//	//00000000000000000000000000000101
//	//00000000000000000000000000000001
//	//
//}
//int main()
//{
//	int num1 = 1;
//	int num2 = 2;
//	num1& num2;//0
//	printf("%d ", num1 & num2);
	//00000000000000000000000000000001
	//00000000000000000000000000000010
	//00000000000000000000000000000000
	//num1 | num2;//3
	//printf("%d ", num1 | num2);
	//00000000000000000000000000000001
	//00000000000000000000000000000010
	//00000000000000000000000000000011
	//num1^ num2;//3
	//printf("%d ", num1 ^ num2);
	//00000000000000000000000000000001
	//00000000000000000000000000000010
	//00000000000000000000000000000011
//	return 0;
//}

//一道变态的面试题：
//不能创建临时变量（第三个变量），实现两个数的交换。

//int main()
//{
//	int a = 3;
//	int b = 5;
//	//交换
//	// 
//	printf("a=%d b=%d\n", a, b);
//	a = a ^ b;
//	b = a ^ b;
//	a = a ^ b;
//	printf("a=%d b=%d\n", a, b);
//
//	//printf("a = %d b = %d\n", a, b);
//	////数值太大会溢出
//	//a = a + b;
//	//b = a - b;
//	//a = a - b;
//	//printf("a = %d b = %d\n", a, b);
//
//	//int c = 0;//空瓶
//	//printf("a = %d b = %d\n", a, b);
//	//c = a;
//	//a = b;
//	//b = c;
//	//printf("a = %d b = %d\n", a, b);
//
//	return 0;
//}

//int main()
//{
//	int a = 3;
//	//a ^ a = 0;
//	//0 ^ a = a;
//	//000
//	//011
//	//011
//	//
//	//011
//	//011
//	//000
//	return 0;
//}

//int main()
//{
//	int a = 13;
//	//把a的二进制中的第5位置成1
//	a = a | (1 << 4);
//	printf("a = %d\n", a);//29
//	//把a的二进制中的第5位置成0
//	a = a & ~(1 << 4);
//	printf("a = %d\n", a);//13
//
//	//
//	//00000000000000000000000000001101
//	//00000000000000000000000000010000
//	//00000000000000000000000000011101
//	// 	                          
//	//1<<4
//	//00000000000000000000000000000001
//
//	//00000000000000000000000000011101
//	//11111111111111111111111111101111
//	//00000000000000000000000000010000
//	//00000000000000000000000000001101
//	//1<<4
//	return 0;
//}

//编写代码实现：求一个整数存储在内存中的二进制中1的个数
//让整数的最低位&1 就能得到这个数的最低位是1还是0  然后再右移1位 这样倒数第二位就会变成最低位然后再&1 以此类推

//int main()
//{
//	int a = 12;
//	int count = 0;
//	int i = 0;
//	//printf("%d",a & 1);
//	for (i = 0; i < 32; i++)
//	{
//		if (1 == ((a>>i) & 1))
//		{
//			count++;
//		}
//	}
//	printf("二进制中1的个数:%d", count);
//	return 0;
//}

//int main()
//{
//	int num = 10;
//	int count = 0;//计数
//	while (num)
//	{
//		if (num % 2 == 1)
//		{
//			count++;
//		}
//		num = num / 2;
//	}
//	printf("二进制中1的个数 = %d\n", count);
//	return 0;
//}

//赋值操作符
//赋值操作符 =
//复合赋值符 +=	   -=    *=    /=    %=      >>=     <<=     &=           |=           ^=
//			加等  减等  乘等  除等   模等  右移等   左移等   按位与等    按位或等    按位异或等

//int main()
//{
//	int a = 10;
//	a = 100;
//	a = a + 100;//1
//	a += 100;   //2
//	a = a >> 3;
//	a >>= 3;
//	return 0;
//}
//=  -- 赋值
//== -- 判断

//单目操作符  ！	

//int main()
//{
//	int flag = 0;
//	printf("%d\n", !flag);//
//
//	//flag为真，打印hehe
//	//if (flag)
//	//{
//	//	printf("hehe\n");
//	//}
//	////flag为假,打印haha
//	//if (!flag)
//	//{
//	//	printf("haha\n");
//	//}
//	return 0;
//}
//单目操作符 - 只有一个操作数
//int main()
//{
//	int a = 10;
//	a = -a;
//	printf("%d\n", a);
//	return 0;
//}
//sizeof()
//int  main()
//{
//	short s = 5;
//	int a = 10;
//	printf("%d\n", sizeof(s = a + 2));//
//	printf("%d\n", s);//
//
//	//int a = 10;
//	//int arr[10] = { 0 };
//	//printf("%d\n", sizeof(arr));//单位是字节
//	//printf("%d\n", sizeof(int [10]));//40 - int [10]是arr数组的类型
//
//
//	//printf("%d\n", sizeof(a));//计算a所占空间的大小，单位是字节
//	//printf("%d\n", sizeof(int));
//	//printf("%d\n", sizeof a);//变量名可以省略圆括号
//	//sizeof是一个操作符，不是函数
//
//	return 0;
//}

//~按位取反 ->181行代码有个题可用按位取反
//int main()
//{
//	int a = -1;
//	//10000000000000000000000000000001 - 原码
//	//11111111111111111111111111111110 - 反码
//	//11111111111111111111111111111111 - 补码
//	//~ 按位取反
//	//11111111111111111111111111111111
//	//00000000000000000000000000000000
//	//
//	int b = ~a;
//	printf("%d\n", a);
//	printf("%d\n", b);
//
//	return 0;
//}

//垃圾代码 有问题 Linux结果10 Windows12
//int main()
//{
//	int a = 1;
//	int b = (++a) + (++a) + (++a);
//	printf("%d\n", b);
//
//	return 0;
//}

//& 取地址    *  间接访问操作符(解引用操作符)

//int main()
//{
//	int a = 10;
//	printf("%p\n", &a);//& - 取地址操作符
//	int * pa = &a;//pa是用来存放地址的 - pa就是一个指针变量
//	*pa = 20;//* - 解引用操作符 - 间接访问操作符
//	printf("%d\n", a);//20
//
//	return 0;
//}

//(强制类型转换)
//int main()
//{
//	int a = (int)3.14;
//
//	return 0;
//}
//

//
//int main()
//{
//	int a = 3;
//	int b = 5;
//	//if (a == b)
//	//if(a != b)
//	//if(a>b)
//	//if(a < b)
//	if(a <= b)
//	{
//
//	}
//	return 0;
//}
// = 赋值 == 判断相等

//== 
//比较2个字符串相等 不能使用 == 
//

//int main()
//{
//	int a = 3;
//	int b = 5;
//	//if (a && b)
//	if(a || b)
//	{
//		printf("hehe\n");
//	}
//	return 0;
//}
//int main()
//{
//    int i = 0, a = 0, b = 2, c = 3, d = 4;
//    //i = a++ && ++b && d++;
//
//    i = a++ || ++b || d++;//1 3 3 5
//    printf("a = %d\nb = %d\nc = %d\nd =%d\n", a, b, c, d);//1 2 3 4
//
//    return 0;
//}

//条件操作符 -->三木操作符

//int main()
//{
//	int a = 3;
//	int b = 0;
//
//	if (a > 5)
//		b = 1;
//	else
//		b = -1;
//
//	//三目操作符
//	b = (a > 5 ? 1 : -1);
//	return 0;
//}

//逗号表达式
//逗号表达式，就是用逗号隔开的多个表达式。 逗号表达式，从左向右依次执行。整个表达式的结果是最后一个表达式的结果。

//int main()
//{
//	int a = 3;
//	int b = 5;
//	int c = 0;
//	//逗号表达式 - 要从做向右依次计算，但是整个表达式的结果是最后一个表达式的结果
//
//	int d = (c = 1, a = c + 3, b = a - 4, c += b);
//
//	//c=10  a=8         b=4    
//	printf("%d\n", d);
//
//	return 0;
//}

//下标引用、函数调用和结构成员
//[] - 下标引用操作符

//int main()
//{
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	//              0 1     4
//	printf("%d\n", arr[4]);//[] - 就是下标引用操作符
//	//[] 的操作数是2个：arr , 4
//	// 
//	//3+5；
//	return 0;
//}

//() - 函数调用操作符

//函数的定义
//int Add(int x, int y)
//{
//	return x + y;
//}
//void test()
//{}
//
//int main()
//{
//	int a = 10;
//	int b = 20;
//	//函数调用
//	int ret = Add(a, b);//() - 函数调用操作符
//	test();
//
//	return 0;
//}

//结构成员访问操作符
//.
//->

//结构体
//
//int float char short 
//double long 
//
//书：书名，书号，定价
//人：名字，年龄，性别
//


//创建了一个自定义的类型

//struct Book
//{
//	//结构体的成员(变量)
//	char Name[20];
//	char id[20];
//	double price;
//};
//int main()
//{
//
//	//结构体变量名.成员名
//	struct Book b = { "C语言","C20211020",55.50 };
//	struct Book* pb = &b;
//	printf("书名:%s\n", pb->Name);
//	printf("书号:%s\n", pb->id);
//	printf("定价:%lf\n", pb->price);
//	printf("书名:%s\n", (*pb).Name);
//	printf("书号:%s\n", (*pb).id);
//	printf("定价:%lf\n", (*pb).price);
//	//printf("书名:%s\n",b.Name);
//	//printf("书号:%s\n",b.id);
//	//printf("定价:%lf\n",b.price);
//	return 0;
//}

//表达式求值
//表达式求值的顺序一部分是由操作符的优先级和结合性决定。 同样，有些表达式的操作数在求值的过程中可能需要转换为其他类型。
//int main()
//{
//	int a = 3;
//	int b = 5;
//	int c = a + b * 7;
//
//	return 0;
//}

//隐式类型转换
//C的整型算术运算总是至少以缺省整型类型的精度来进行的。
//为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转换为普通整型，这种转换称为整型提升
//
//int main()
//{
	//char a = 3;
	//00000000000000000000000000000011
	//00000011  - > a
	//char b = 127;
	//00000000000000000000000001111111
	//01111111  - > b

	//char c = a + b;
	//00000011  - > a整型提升后
	//00000000000000000000000000000011

	//01111111  - > b整型提升后
	//00000000000000000000000001111111  b
	// 
	//00000000000000000000000000000011	a
	//									+
	//00000000000000000000000001111111  b
	//00000000000000000000000010000010
	//		a + b = 1000010    需要以整型的形式打印所以要发生整型提升 打印看到的是原码 存在内存中为补码 所以这里要求原码
	//11111111111111111111111110000010  补码
	//11111111111111111111111110000001	反码
	//10000000000000000000000001111110	原码
	//-126
	//发现a和b都是char类型,都没有达到一个int的大小
	//这里就会发生整型提升
//	printf("%d\n", c);//-126
//	return 0;
//}

//整型提升	

//int main()
//{
//	char a = 0xb6;
//	short b = 0xb600;
//	int c = 0xb6000000;
//
//	if (a == 0xb6)//字符a 需要整型提升
//		printf("a");
//	if (b == 0xb600)//短整型b 需要整型提升
//		printf("b");
//	if (c == 0xb6000000)
//		printf("c");
//	return 0;
//}

//int main()
//{
//	char c = 1;
//	printf("%u\n", sizeof(c));//1
//	printf("%u\n", sizeof(+c));//4 只要参与运算 就会整型提升
//	printf("%u\n", sizeof(-c));//4
//	printf("%u\n", sizeof(!c));//4 gcc - 4
//	return 0;
//}
//int main()
//{
//	int a = 3;
//	int b = 5;
//	short s = 5;
//	sizeof(s = a + 3);
//	a + b;//值属性，类型属性 int
//	return 0;
//}
 
 
// 算术转换
//某个操作符的各个操作数属于不同的类型，那么除非其中一个操作数的转换为另一个操作数的类型，否则操作就无法进行。
//下面的层次体系称为寻常算术转换。

//int main()
//{
//	int a = 4;
//	float f = 4.5f;
//	a + f;
//	return 0;
//}

//操作符的属性
//复杂表达式的求值有三个影响的因素。
//1. 操作符的优先级
//2. 操作符的结合性
//3. 是否控制求值顺序。

//int main()
//{
//	int a = 4;
//	int b = 5;
//	//int c = a + b * 7;//优先级决定了计算顺序
//	int c = a + b + 7;//优先级不起作用，结合性决定了，顺序
//	return 0;
//}

//int fun()
//{
//    static int count = 1;
//    return ++count;
//}
//int main()
//{
//    int answer;
//    //2-3*4 = -10
//    answer = fun() - fun() * fun();
//    printf("%d\n", answer);//输出多少？
//    return 0;
//}

int main()
{
	int i = 1;
	int ret = (++i) + (++i) + (++i);
	printf("%d\n", ret);

	return 0;
}
//VS  - 12
//gcc - 10